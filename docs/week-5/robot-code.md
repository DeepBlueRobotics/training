Now that you know how OOP works in Java, let's finally apply what you've learned to our actual robot code. We're actually going to start looking at and writing robot code! Hell yeah! Congrats on making it here.

!!! note
    We'll be assuming that our robot code package is `frc199.robot` and our code lives in `src/main/java/frc199/robot` but honestly the package naming scheme varies by year and by team, and it doesn't matter as long as you keep it consistent for a project.

A robot project structure generally looks something like this:
```
src/main/java/frc199/robot/
  |   Main.java
  |   Robot.java
  |   RobotMap.java
  |   OI.java
  |
  └── subsystems/
  |   |   Drivetrain.java
  |   |   Intake.java
  |   |   Climber.java
  |   |   Lift.java
  |
  └── commands/
  |   |   Drive.java
  |   |   Climb.java
  |   |   RunIntake.java
  |   |   RunEject.java
  |   |   MoveLift.java
  |   |   Autonomous.java
  |
  └── lib/
      |   Characterization.java
      |   OtherFancyMathStuff.java
```
It's a lot, so let's break it down. This is an intro to our robot structure, so we won't go into specifics on how to actually write the code until the next section.

## Main.java
This file is autogenerated, and there is rarely any reason to touch this file at all. It contains the `main` method that you're now faimilar with, which is run at startup and starts up the rest of the robot code.
```java
/*
  Note: slightly modified from the autogenerated code for clarity
*/
package frc199.robot;

import edu.wpi.first.wpilibj.RobotBase;

public final class Main {
  private Main() {
  }

  public static void main(String[] args) {
    RobotBase.startRobot(Robot::new);
  }
}
```

## Robot.java
This file is the control center of the robot. It initializes and contains the Objects for all the subsystems, and has the methods that are called to run the robot.

<!-- MOVE THIS TO THE NEXT SECTION
There are two types of methods that are in `Robot.java`: 

* Initializer methods end with `Init` and are called once a the start of a mode. Use it for code that needs to be run right when that mode starts, such as starting a timer.
* Periodic methods end with `Periodic` and are called in a loop, around once per 20 milliseconds, when the robot is set to its respective mode. Use it for code that needs to be run continuously throughout a mode's execution, such as a scheduler loop for commands.

There are four robot modes: 

* `autonomous`, when the robot is controlled autonomously. Occurs during the first 15 seconds of a match.
* `teleop`, when the robot is teleoperated, AKA controlled by the drive team. Occurs during the remaining 2 minutes and 15 seconds of a match following the autonomous mode.
* `disabled`, the state the robot is in before and after the match. During this period, all motors and pneumatic devices on the robot are disabled.
* `test` is the mode that can be used for testing purposes (although we rarely use it since we can just set the robot to teleop when testing).

Thus, methods look like `autonomousInit()`, `autonomousPeriodic()`, `teleopInit()`, `teleopPeriodic()`, etc.

In addition, there are two more methods:

* `robotInit()` is called once when the robot starts. Use it to initialize and store subsystem objects and other things.
* `robotPeriodic()` is called every 20 milliseconds or so the entire time the robot is on. Typically not used for much but maybe you have some usecase for this method.
-->
## RobotMap.java
This is where we create and store the objects for the motor controllers and solenoids that are used in the subsystems. Its primary use is to map the port numbers on the PDP, CAN bus, and solenoid(s) to specific Objects in the code. 

For example, if our climber motor was a Victor SP that was plugged into port 2 of the PDP, the code would look something like this:
```java
VictorSP climberMotor = new VictorSP(2);
```

## OI.java
OI stands for Operator Interface. Like that makes its function any clearer. 

The OI class is similar to RobotMap, but instead of connecting motor and solenoid ports to their Objects in the code, it connects joystick/controller buttons to commands and functionality in the code. 

For example, if you want to run the intake when you press button 3 on your left joystick (which is plugged into USB port zero), here would be the code:
```java
Joystick leftJoy = new Joystick(0);
JoystickButton intakeBtn = new JoystickButton(leftJoy, 3);
intakeBtn.whenPressed(new RunIntake());
```

## Subsystems
Subsystems are anoter name for robot mechanisms, such as a drivetrain, an elevator, an intake, or a climber. The subystem classes contain the Objects for the motor controllers and solenoids that are taken from `RobotMap` and have methods for controlling the subsystem, which are used by commands.

## Commands
Commands are what run the robot. For example, there may be a `RunIntake` command that runs two motors to the wheels that intake a game piece. 

In addition there are instant commands, which run instantly. For example, you might have an instant command called `ActuatePiston` that actuates a piston on the robot.

Finally, there are command groups. Command groups run a series of commands. You can mix and match whether you want to run a command right after the previous one (called running sequentially) or at the same time as the previos command (called running in parallel). 

## Lib
The `lib` folder is where we would store the complex calculations, wrappers, or other things that do not directly interact with the robot, but are rather called on by commands or subsystems to assist in their execution. Stuff in this folder would be valuable code that we would actually want to keep and develop on from one year to another, such as drivetrain characterization, motion profiling, or swerve drive code.